from fastapi import FastAPI, UploadFile, File, Form, HTTPException
from starlette.middleware.base import BaseHTTPMiddleware
import os
import uuid
import numpy as np
import faiss
from typing import List
from src.extract_embedding import extract_embeddings
from src.build_faiss import update_or_create_faiss_index
from src.search_with_faiss import load_faiss_index, search_similar_images
import sys

from fastapi.middleware.cors import CORSMiddleware



app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Permet √† toutes les origines d'acc√©der
    allow_credentials=True,
    allow_methods=["*"],  # Permet toutes les m√©thodes HTTP
    allow_headers=["*"],  # Permet tous les headers
)


# Configuration des dossiers
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))  # Racine du projet IA-MIST
sys.path.append(BASE_DIR)  # Ajoute la racine du projet IA-MIST au chemin Python
DATASET_DIR = os.path.join(BASE_DIR, "dataset")  # Assure que dataset/ est bien √† la racine
EMBEDDINGS_FOLDER = os.path.join(DATASET_DIR, "embeddings")  # Corrige l'emplacement d'embeddings

# Middleware pour limiter la taille des requ√™tes
class LimitSizeMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        max_size = 30 * 1024 * 1024  # Limite : 30 Mo
        content_length = request.headers.get("Content-Length")
        if content_length and int(content_length) > max_size:
            raise HTTPException(status_code=413, detail="Request too large")
        return await call_next(request)

app.add_middleware(LimitSizeMiddleware)

EMBEDDING_DIMENSION = 1280

@app.get("/")
def root():
    return {"message": "L'API est en ligne et fonctionne correctement ! üöÄ"}

@app.post("/add/")
async def add_image(category: str, files: List[UploadFile] = File(...)):
    """
    üìå Ajoute une ou plusieurs images √† une cat√©gorie FAISS et v√©rifie si un embedding similaire existe d√©j√†.
    """
    category_folder = os.path.join(EMBEDDINGS_FOLDER, category)
    os.makedirs(category_folder, exist_ok=True)

    print("üìÇ Chargement des images et extraction des embeddings...")
    image_bytes = [await file.read() for file in files]
    embeddings, uuids = extract_embeddings(image_bytes, category)

    if len(embeddings) == 0:
        print("‚ùå Erreur : Aucun embedding extrait.")
        return {"message": "Erreur : Impossible d'extraire les embeddings."}

    print("‚úÖ Embeddings extraits avec succ√®s.")
    print(f"üëâ Dimension des embeddings : {embeddings.shape}")

    # V√©rification de la dimension des embeddings
    if embeddings.shape[1] != 1280: 
        print(f"‚ùå Erreur : Embedding g√©n√©r√© avec une dimension incorrecte ({embeddings.shape[1]}).")
        return {"message": "Erreur embedding g√©n√©r√© incorrect"}

    # Charger les anciens embeddings
    embeddings_file = os.path.join(category_folder, "image_embeddings.npy")
    uuids_file = os.path.join(category_folder, f"image_uuids_{category}.npy")

    if os.path.exists(embeddings_file):
        embeddings_dict = np.load(embeddings_file, allow_pickle=True).item()
    else:
        embeddings_dict = {}

    if os.path.exists(uuids_file):
        existing_uuids = np.load(uuids_file, allow_pickle=True).tolist()
    else:
        existing_uuids = []

    print("üîç V√©rification des similarit√©s...")
    # V√©rifier si un embedding similaire existe d√©j√†
    for new_embedding, _ in zip(embeddings, uuids):
        for existing_uuid, existing_embedding in embeddings_dict.items():
            similarity = np.dot(new_embedding, existing_embedding)  # Produit scalaire pour similarit√© cosinus
            if similarity > 0.99:  # Contrainte de similarit√© (ajustez le seuil selon vos besoins)
                print(f"‚ö†Ô∏è Match parfait d√©tect√© avec l'UUID existant : {existing_uuid}")
                return {
                    "message": "Un match parfait existe, veuillez consulter le post.",
                    "uuid": existing_uuid,
                }
            print("Ce log ne devrait jamais s'afficher !")

    print("‚úÖ Aucun match parfait d√©tect√©. Ajout des nouveaux embeddings.")
    # Ajouter les nouveaux embeddings et UUIDs
    for uuid_val, embedding in zip(uuids, embeddings):
        embeddings_dict[uuid_val] = embedding
    existing_uuids.extend(uuids)

    # Sauvegarder les mises √† jour
    print("üíæ Sauvegarde des embeddings et des UUIDs...")
    np.save(embeddings_file, embeddings_dict)
    np.save(uuids_file, np.array(existing_uuids, dtype=object))

    # Mettre √† jour l'index FAISS
    print("üìà Mise √† jour de l'index FAISS...")
    update_or_create_faiss_index(category)

    response = {
        "message": "Les images ont √©t√© ajout√©es avec succ√®s.",
        "uuids": uuids,
    }
    print("‚úÖ Processus termin√© avec succ√®s.")
    return response




# Endpoint pour lister les images avec v√©rification des UUIDs li√©s aux embeddings
@app.get("/list/")
async def list_images(category: str):
    """
    üìå Retourne la liste des UUIDs enregistr√©s et v√©rifie qu'ils sont li√©s aux embeddings dans l'index FAISS.
    """
    category_folder = os.path.join(EMBEDDINGS_FOLDER, category)
    uuids_file = os.path.join(category_folder, f"image_uuids_{category}.npy")
    embeddings_file = os.path.join(category_folder, "image_embeddings.npy")
    index_path = os.path.join(category_folder, f"faiss_{category}.idx")

    # V√©rifier si les fichiers n√©cessaires existent
    if not os.path.exists(uuids_file) or not os.path.exists(embeddings_file) or not os.path.exists(index_path):
        return {"message": "Aucun index FAISS ou donn√©es associ√©es trouv√©es pour cette cat√©gorie."}

    # Charger les UUIDs et les embeddings
    uuids = np.load(uuids_file, allow_pickle=True).tolist()
    embeddings_dict = np.load(embeddings_file, allow_pickle=True).item()
    index = faiss.read_index(index_path)

    # V√©rifier si tous les UUIDs ont des embeddings associ√©s
    missing_uuids = [uuid for uuid in uuids if uuid not in embeddings_dict]
    linked_uuids = [uuid for uuid in uuids if uuid in embeddings_dict]

    response = {
        "category": category,
        "total_images": len(uuids),
        "faiss_embeddings": index.ntotal,
        "uuids": linked_uuids,
        "missing_uuids": missing_uuids,  # UUIDs sans embeddings associ√©s
        "status": "ok" if not missing_uuids else "Mismatch detected",
    }

    if missing_uuids:
        print(f"‚ö†Ô∏è Les UUIDs suivants n'ont pas d'embeddings associ√©s : {missing_uuids}")

    return response

# Recherche d'images
@app.post("/search/")
async def search_image(category: str, file: UploadFile = File(...)):
    """
    üìå Recherche les images les plus similaires en utilisant FAISS.
    """
    query_image_bytes = await file.read()
    query_results = search_similar_images(category, query_image_bytes, top_k=5)

    if not query_results:
        return {"message": "Aucune image similaire trouv√©e."}

    return query_results


@app.post("/delete/")
async def delete_image(category: str, uuid_to_delete: str = Form(...)):
    """
    üìå Supprime une image de l'index FAISS √† l'aide de son UUID.
    """
    category_folder = os.path.join(EMBEDDINGS_FOLDER, category)
    embeddings_file = os.path.join(category_folder, "image_embeddings.npy")
    uuids_file = os.path.join(category_folder, f"image_uuids_{category}.npy")
    index_path = os.path.join(category_folder, f"faiss_{category}.idx")

    # V√©rifier que les fichiers n√©cessaires existent
    if not os.path.exists(embeddings_file) or not os.path.exists(uuids_file) or not os.path.exists(index_path):
        return {"message": "Erreur : Donn√©es manquantes pour cette cat√©gorie."}

    # Charger les embeddings et les UUIDs
    embeddings_dict = np.load(embeddings_file, allow_pickle=True).item()
    uuids = np.load(uuids_file, allow_pickle=True).tolist()

    if uuid_to_delete not in embeddings_dict:
        return {"message": "Erreur : UUID non trouv√© dans l'index."}

    # Supprimer l'UUID et l'embedding associ√©
    del embeddings_dict[uuid_to_delete]
    uuids.remove(uuid_to_delete)

    # Recr√©er l'index FAISS sans l'embedding supprim√©
    all_embeddings = np.array(list(embeddings_dict.values())).astype("float32")
    index = faiss.IndexFlatIP(all_embeddings.shape[1])  # Recr√©e un nouvel index FAISS
    index.add(all_embeddings)  # Ajoute les embeddings restants au nouvel index

    # Sauvegarder le nouvel index FAISS
    faiss.write_index(index, index_path)

    # Sauvegarder les mises √† jour
    np.save(embeddings_file, embeddings_dict)
    np.save(uuids_file, np.array(uuids, dtype=object))

    return {"message": f"Image avec UUID {uuid_to_delete} et son embedding associ√© ont √©t√© supprim√©s avec succ√®s de {category}."}



@app.post("/test-files/")
async def test_files(files: List[UploadFile] = File(...)):
    file_sizes = []
    for file in files:
        content = await file.read()
        file_sizes.append(len(content))
    return {"file_sizes": file_sizes}
